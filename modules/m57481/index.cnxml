<document xmlns="http://cnx.rice.edu/cnxml">
  <title>The Fast Fourier Transform</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m57481</md:content-id>
  <md:title>The Fast Fourier Transform</md:title>
  <md:abstract/>
  <md:uuid>34418b41-f66e-425c-bec1-5d2289051e9f</md:uuid>
</metadata>

<content>
    <section id="idm411767521152">
      <title>Tasks and Algorithms</title>
      <para id="idm411767520608">The first thing to know about the <term>fast Fourier transform</term>, or <term>FFT</term>, is that it actually is not a unique type of mathematical transform at all. The FFT is simply a method, or <emphasis effect="italics">algorithm</emphasis>, for the task of computing a DFT. In that way, it is similar to the task of sorting a group of numbers from smallest to largest. No matter how you might go about the task of sorting the numbers, there is only one correctly sorted answer. Some methods to sorting, however, may be quicker (take fewer steps) than others. For example, you could put the numbers in one list, and then progressively traverse through the list, comparing two adjacent items at a time and swapping them if necessary; each time you traverse the list, you will have put the next largest number in its place. This approach is usually called a "Bubble Sort." Another approach is to split the list of numbers into two sets, then divide each set in two, and divide those sets, and so on, until each little set has two (or fewer) numbers. You will then sort each set of two numbers (easy!), and then progressively combine these sorted sets together (also easy!) until a single sorted set remains. This is called a "Merge Sort," and is known as a "divide and conquer" algorithm.</para>
      <para id="eip-437">Now, these two sorting methods achieve the same results, but the Merge Sort typically does so in far fewer steps (although the Bubble Sort will process an already or nearly sorted list quicker). If there are <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math> items in a list, Merge Sort requires about <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2 N</m:annotation></m:semantics></m:math> steps, while the Bubble Sort requires about <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:annotation encoding="math/tex">N^2</m:annotation></m:semantics></m:math>. Even with lists as small as <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>32</m:mn><m:annotation encoding="math/tex">32</m:annotation></m:semantics></m:math> items, that makes a big difference, the difference between <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>160</m:mn><m:annotation encoding="math/tex">160</m:annotation></m:semantics></m:math> and <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>1024</m:mn><m:annotation encoding="math/tex">1024</m:annotation></m:semantics></m:math>. So it is with the discrete Fourier transform. The DFT is a simple formula:</para>
      <para id="idm411767506240"><m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>X</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo><m:mo>=</m:mo><m:munderover><m:mo movablelimits="false">∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:msup><m:mi>e</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>−</m:mo><m:mi>j</m:mi><m:mfrac><m:mrow><m:mn>2</m:mn><m:mi>π</m:mi></m:mrow><m:mi>N</m:mi></m:mfrac><m:mi>k</m:mi><m:mi>n</m:mi></m:mrow></m:msup></m:mrow><m:annotation encoding="math/tex">X[k]=\sum\limits_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}</m:annotation></m:semantics></m:math>.</para>
      <para id="idm411767490400"> It would be possible to calculate this as a sum of <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math> multiplications (going from <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:annotation encoding="math/tex">n=0</m:annotation></m:semantics></m:math> to <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>n</m:mi><m:mo>=</m:mo><m:mi>N</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:annotation encoding="math/tex">n=N-1</m:annotation></m:semantics></m:math>), doing that <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math> times (for each <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mi>k</m:mi><m:annotation encoding="math/tex">k</m:annotation></m:semantics></m:math>, again from <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>0</m:mn><m:annotation encoding="math/tex">0</m:annotation></m:semantics></m:math> to <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>N</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:annotation encoding="math/tex">N-1</m:annotation></m:semantics></m:math>). That's about <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:annotation encoding="math/tex">N^2</m:annotation></m:semantics></m:math> multiplications and additions. But, there are many different ways one could calculate the DFT, just as there are many ways to sort a list. As with Merge Sort, there is a divide-and-conquer approach to finding the DFT which does so with far fewer computational steps, only about <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2 N</m:annotation></m:semantics></m:math>.</para>
    </section>
    <section id="idm411767471200">
      <title>The FFT: A Divide and Conquer Algorithm for Finding a DFT</title>
      <para id="idm411767470688">The intuition behind the FFT algorithm is the same as that of the Merge Sort. The Merge Sort operates on the idea that it is easy to take two sorted lists and combine them into one large sorted list: you simply compare the beginning of each list, pick off the smallest of the two and place it in a new list, and then keep on doing that until the two lists are empty.</para>
      <para xmlns:m="http://www.w3.org/1998/Math/MathML" id="eip-747">Something similar happens with the DFT. Suppose you have some signal <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math>, which you can split into two smaller signals in terms of its even and odd indices, <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[2n]</m:annotation></m:semantics></m:math> and <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[2n+1]</m:annotation></m:semantics></m:math>. Suppose now that you already know the DFTs of these two smaller signals, and call them <m:math><m:semantics><m:mrow><m:mi>E</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">E[k]</m:annotation></m:semantics></m:math> and <m:math><m:semantics><m:mrow><m:mi>O</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">O[k]</m:annotation></m:semantics></m:math>. Then it is easy to find the DFT of the whole signal, <m:math><m:semantics><m:mrow><m:mi>X</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">X[k]</m:annotation></m:semantics></m:math>, from these smaller ones:</para><para id="idm411767448928"><m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>X</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo><m:mo>=</m:mo><m:mi>E</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo><m:mo>+</m:mo><m:msup><m:mi>e</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mi>j</m:mi><m:mfrac><m:mrow><m:mn>2</m:mn><m:mi>π</m:mi></m:mrow><m:mi>N</m:mi></m:mfrac><m:mi>k</m:mi></m:mrow></m:msup><m:mi>O</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">X[k]=E[k]+e^{j\frac{2\pi}{N}k}O[k]</m:annotation></m:semantics></m:math>.</para>
      <para id="idm411767436704">A proof of this follows. For simplification of notation, we let <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:msub><m:mi>W</m:mi><m:mi>N</m:mi></m:msub><m:mo>=</m:mo><m:msup><m:mi>e</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>−</m:mo><m:mi>j</m:mi><m:mfrac><m:mrow><m:mn>2</m:mn><m:mi>π</m:mi></m:mrow><m:mi>N</m:mi></m:mfrac></m:mrow></m:msup></m:mrow><m:annotation encoding="math/tex">W_N=e^{-j\frac{2\pi}{N}}</m:annotation></m:semantics></m:math>:</para>
      <para id="idm411767429520"><m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><m:mtr><m:mtd><m:mi>X</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mtd><m:mtd><m:mi/><m:mo>=</m:mo><m:munderover><m:mo>∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mspace width="thinmathspace"/><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mi>k</m:mi><m:mi>n</m:mi></m:mrow></m:msubsup></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mi/><m:mo>=</m:mo><m:munderover><m:mo>∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mspace width="thinmathspace"/><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mi>k</m:mi><m:mo stretchy="false">(</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:msubsup><m:mtext> </m:mtext><m:mo>+</m:mo><m:mtext> </m:mtext><m:munderover><m:mo>∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn><m:mo stretchy="false">]</m:mo><m:mspace width="thinmathspace"/><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mi>k</m:mi><m:mo stretchy="false">(</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn><m:mo stretchy="false">)</m:mo></m:mrow></m:msubsup></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mi/><m:mo>=</m:mo><m:munderover><m:mo>∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mspace width="thinmathspace"/><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mn>2</m:mn><m:mi>k</m:mi><m:mi>n</m:mi></m:mrow></m:msubsup><m:mtext> </m:mtext><m:mo>+</m:mo><m:mtext> </m:mtext><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mi>k</m:mi></m:msubsup><m:munderover><m:mo>∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn><m:mo stretchy="false">]</m:mo><m:mspace width="thinmathspace"/><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mn>2</m:mn><m:mi>k</m:mi><m:mi>n</m:mi></m:mrow></m:msubsup></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mi/><m:mo>=</m:mo><m:munderover><m:mo>∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mspace width="thinmathspace"/><m:msubsup><m:mi>W</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>k</m:mi><m:mi>n</m:mi></m:mrow></m:msubsup><m:mtext> </m:mtext><m:mo>+</m:mo><m:mtext> </m:mtext><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mi>k</m:mi></m:msubsup><m:munderover><m:mo>∑</m:mo><m:mrow class="MJX-TeXAtom-ORD"><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mn>2</m:mn><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn><m:mo stretchy="false">]</m:mo><m:mspace width="thinmathspace"/><m:msubsup><m:mi>W</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:mrow class="MJX-TeXAtom-ORD"><m:mi>k</m:mi><m:mi>n</m:mi></m:mrow></m:msubsup></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mi/><m:mo>=</m:mo><m:mi>E</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo><m:mtext> </m:mtext><m:mo>+</m:mo><m:mtext> </m:mtext><m:msubsup><m:mi>W</m:mi><m:mi>N</m:mi><m:mi>k</m:mi></m:msubsup><m:mspace width="thinmathspace"/><m:mi>O</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mtd></m:mtr></m:mtable><m:annotation encoding="math/tex">\begin{align*}
X[k] &amp;= \sum_{n=0}^{N-1} x[n]\, W_N^{kn}\\
&amp;=\sum_{n=0}^{N/2-1} x[2n]\, W_N^{k (2n)} ~+~
\sum_{n=0}^{N/2-1} x[2n+1]\, W_N^{k(2n+1)}\\
&amp;=\sum_{n=0}^{N/2-1} x[2n]\, W_N^{2kn} ~+~ W_N^k \sum_{n=0}^{N/2-1} x[2n+1]\, W_N^{2kn} \\
&amp;=\sum_{n=0}^{N/2-1} x[2n]\, W_{N/2}^{kn} ~+~ W_N^k \sum_{n=0}^{N/2-1} x[2n+1]\, W_{N/2}^{kn} \\
&amp;=E[k] ~+~ W_N^k\, O[k]
\end{align*}</m:annotation></m:semantics></m:math>.</para>
      <para xmlns:m="http://www.w3.org/1998/Math/MathML" id="idm411767314144">You will note that the <m:math><m:semantics><m:mi>k</m:mi><m:annotation encoding="math/tex">k</m:annotation></m:semantics></m:math> in <m:math><m:semantics><m:mrow><m:mi>X</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">X[k]</m:annotation></m:semantics></m:math> runs from <m:math><m:semantics><m:mn>0</m:mn><m:annotation encoding="math/tex">0</m:annotation></m:semantics></m:math> to <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:annotation encoding="math/tex">N-1</m:annotation></m:semantics></m:math>, but that the even and odd DFTs are only of length <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:annotation encoding="math/tex">N/2</m:annotation></m:semantics></m:math>. It may seem a little strange to consider the values of these DFTs for <m:math><m:semantics><m:mi>k</m:mi><m:annotation encoding="math/tex">k</m:annotation></m:semantics></m:math> greater than <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:annotation encoding="math/tex">N/2</m:annotation></m:semantics></m:math> (as is necessary in the formula). But there is no problem with this, since DFTs are periodic; as those DFTs are length <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:annotation encoding="math/tex">N/2</m:annotation></m:semantics></m:math>, we have <m:math><m:semantics><m:mrow><m:mi>E</m:mi><m:mo stretchy="false">[</m:mo><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn><m:mo>+</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo><m:mo>=</m:mo><m:mi>E</m:mi><m:mo stretchy="false">[</m:mo><m:mi>k</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">E[N/2+k]=E[k]</m:annotation></m:semantics></m:math> for those values between <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:annotation encoding="math/tex">N/2</m:annotation></m:semantics></m:math> and <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:annotation encoding="math/tex">N-1</m:annotation></m:semantics></m:math>.
So, we have that the DFT of an <m:math><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math>-length signal is simply the weighted sum of two <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:annotation encoding="math/tex">N/2</m:annotation></m:semantics></m:math>-length DFTs. If we, somehow, are given the DFT of those even/odd sub-signals, there are only <m:math><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math> additions and multiplications involved in finding the DFT of the whole signal, which is of course much better than the <m:math><m:semantics><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:annotation encoding="math/tex">N^2</m:annotation></m:semantics></m:math> needed to find the DFT by straightforward calculation of the DFT sum.</para><para id="eip-299">Of course, this requires that we had the DFTs of the sub-divided signals! How do we find those? Well, again we will divide those sub-signals by even/odd indices, and then do that again, and again, and again, until we have lots of length-<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>2</m:mn><m:annotation encoding="math/tex">2</m:annotation></m:semantics></m:math> sub-signals. The DFT of a length-<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>2</m:mn><m:annotation encoding="math/tex">2</m:annotation></m:semantics></m:math> signal is <emphasis effect="italics">very </emphasis>easy to compute. If we call such a signal <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>t</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">t[n]</m:annotation></m:semantics></m:math>, then <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>T</m:mi><m:mo stretchy="false">[</m:mo><m:mn>0</m:mn><m:mo stretchy="false">]</m:mo><m:mo>=</m:mo><m:mi>t</m:mi><m:mo stretchy="false">[</m:mo><m:mn>0</m:mn><m:mo stretchy="false">]</m:mo><m:mo>+</m:mo><m:mi>t</m:mi><m:mo stretchy="false">[</m:mo><m:mn>1</m:mn><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">T[0]=t[0]+t[1]</m:annotation></m:semantics></m:math> and <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>T</m:mi><m:mo stretchy="false">[</m:mo><m:mn>1</m:mn><m:mo stretchy="false">]</m:mo><m:mo>=</m:mo><m:mi>t</m:mi><m:mo stretchy="false">[</m:mo><m:mn>0</m:mn><m:mo stretchy="false">]</m:mo><m:mo>−</m:mo><m:mi>t</m:mi><m:mo stretchy="false">[</m:mo><m:mn>1</m:mn><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">T[1]=t[0]-t[1]</m:annotation></m:semantics></m:math> (this is easy to verify for yourself).</para>
      <para id="eip-116">With the DFTs of our many length-<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>2</m:mn><m:annotation encoding="math/tex">2</m:annotation></m:semantics></m:math> signals in hand, we use the even/odd sum formula to combine them find the DFT of the length-<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>4</m:mn><m:annotation encoding="math/tex">4</m:annotation></m:semantics></m:math> signals, and then length-<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>8</m:mn><m:annotation encoding="math/tex">8</m:annotation></m:semantics></m:math>, and so on until we have the DFT of the whole signal. This is known as a decimation-in-time FFT, and while it assumes a signal length that is a power of <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mn>2</m:mn><m:annotation encoding="math/tex">2</m:annotation></m:semantics></m:math>, there are ways to apply the approach to signals of other lengths. The figure below illustrates the process of splitting up the DFT into smaller and smaller half-size DFTs:
</para>
      <figure xmlns:m="http://www.w3.org/1998/Math/MathML" id="dfts" orient="vertical"><subfigure id="fft8-plot">
          <media id="fft8" alt="Image">
            <image mime-type="image/png" src="../../media/4ptfft.png" width="300" print-width="2in"/>
          </media>
          <caption>The DFT of a length-<m:math><m:semantics><m:mn>8</m:mn><m:annotation encoding="math/tex">8</m:annotation></m:semantics></m:math> signal can be split into the the weighted sum of two length-<m:math><m:semantics><m:mn>4</m:mn><m:annotation encoding="math/tex">4</m:annotation></m:semantics></m:math> DFTs, namely, the DFTs of the even and odd indices.</caption>
        </subfigure>
        <subfigure id="fft4-plot">
          <media id="fft4" alt="Image">
            <image mime-type="image/png" src="../../media/2ptfft.png" width="300" print-width="2in"/>
          </media>
          <caption>Each length-<m:math><m:semantics><m:mn>4</m:mn><m:annotation encoding="math/tex">4</m:annotation></m:semantics></m:math> DFT is split into the weighted sum of two length-<m:math><m:semantics><m:mn>2</m:mn><m:annotation encoding="math/tex">2</m:annotation></m:semantics></m:math> DFTs.</caption>
        </subfigure>
        <subfigure id="fft2-plot">
          <media id="fft2" alt="Image">
            <image mime-type="image/png" src="../../media/1ptfft.png" width="300" print-width="2in"/>
          </media>
          <caption>The length-<m:math><m:semantics><m:mn>2</m:mn><m:annotation encoding="math/tex">2</m:annotation></m:semantics></m:math> DFTs are found, and from there the rest of the overall DFT can be computed according to the half-size weighted sums.</caption>
        </subfigure>
        <subfigure id="butterfly-plot">
          <media id="butterfly" alt="Image">
            <image mime-type="image/png" src="../../media/butterfly.png" width="300" print-width="2in"/>
          </media>
          <caption>The <m:math><m:semantics><m:mn>2</m:mn><m:annotation encoding="math/tex">2</m:annotation></m:semantics></m:math>-length DFTs are simple to find, just an addition and a subtraction. When those operations are represented graphically, they are said to have a "butterfly" structure.</caption>
        </subfigure>
        
      <caption>The FFT is a "divide and conquer" algorithmic approach to finding a DFT. An <m:math><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math>-length DFT can be found as the weighted sum of two <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>2</m:mn></m:mrow><m:annotation encoding="math/tex">N/2</m:annotation></m:semantics></m:math>-length DFTs, and each of those are the sum of two <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mrow class="MJX-TeXAtom-ORD"><m:mo>/</m:mo></m:mrow><m:mn>4</m:mn></m:mrow><m:annotation encoding="math/tex">N/4</m:annotation></m:semantics></m:math>-length DFTs, and so on.</caption></figure></section><section id="idm411767204880">
        <title>Computational Savings of the FFT</title>
        <para xmlns:m="http://www.w3.org/1998/Math/MathML" id="idm411767204320">Recall that a straightforward sum and multiplication computation of the DFT requires about <m:math><m:semantics><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:annotation encoding="math/tex">N^2</m:annotation></m:semantics></m:math> operations; to be precise, it is <m:math><m:semantics><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:annotation encoding="math/tex">N_2</m:annotation></m:semantics></m:math> multiplications and <m:math><m:semantics><m:mrow><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:mo>−</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N^2-N</m:annotation></m:semantics></m:math> additions. The FFT approach requires about <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2 N</m:annotation></m:semantics></m:math> operations: <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi><m:mo>−</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2 N -N</m:annotation></m:semantics></m:math> multiplications and <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2 N</m:annotation></m:semantics></m:math> additions. For small signal sizes, the difference between <m:math><m:semantics><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:annotation encoding="math/tex">N^2</m:annotation></m:semantics></m:math> and <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2 N</m:annotation></m:semantics></m:math> is not that significant. But as <m:math><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math> gets even moderately large (say, <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:mo>=</m:mo><m:mn>32</m:mn></m:mrow><m:annotation encoding="math/tex">N=32</m:annotation></m:semantics></m:math> and up), the difference becomes larger and larger. By the time we consider typical signal sizes in signal processing, in which <m:math><m:semantics><m:mi>N</m:mi><m:annotation encoding="math/tex">N</m:annotation></m:semantics></m:math> is in the millions, taking <m:math><m:semantics><m:msup><m:mi>N</m:mi><m:mn>2</m:mn></m:msup><m:annotation encoding="math/tex">N^2</m:annotation></m:semantics></m:math> complex operations is prohibitive in terms of time and memory costs, while <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2N</m:annotation></m:semantics></m:math> is very manageable.</para></section>

  </content>
</document>