<document xmlns="http://cnx.rice.edu/cnxml">
  <title>Fast Convolution with the FFT</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m57650</md:content-id>
  <md:title>Fast Convolution with the FFT</md:title>
  <md:abstract/>
  <md:uuid>3c0a4ffb-e056-4637-94eb-6e1da70c808b</md:uuid>
</metadata>

<content>
    <para id="delete_me">We have seen, previously, these four important signal processing facts:</para><list id="idm110985592112" list-type="bulleted">
      <item>the output of infinite-length LTI systems can be found via linear convolution</item>
      <item>linear convolution can be found through circular convolution, through zero-padding</item>
      <item>there is an equivalence between circular convolution in the signals' time domain and multiplication in their frequency domain</item>
      <item>the FFT is an algorithm that can quickly compute a DFT</item>
    </list>
    <para id="idm110985590352">Perhaps at the time it may have seemed that these findings were unrelated to each other. But as we now string them together, you can see the incredibly significant consequence: the output of LTI systems can be computed very efficiently. This truth has supported the incredible advances in signal processing over the past fifty years.</para>
    <section id="idm110985589760">
      <title>Putting It All Together...</title>
      <para xmlns:m="http://www.w3.org/1998/Math/MathML" id="idm110985589216">Suppose we have an LTI system with an impulse response of <m:math><m:semantics><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">h[n]</m:annotation></m:semantics></m:math> and an input of <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math>. We would like to find the output, <m:math><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math>. We could find this output via linear (infinite length) convolution. If the length of the impulse response is <m:math><m:semantics><m:msub><m:mi>N</m:mi><m:mi>h</m:mi></m:msub><m:annotation encoding="math/tex">N_h</m:annotation></m:semantics></m:math> and that of the input signal is <m:math><m:semantics><m:msub><m:mi>N</m:mi><m:mi>x</m:mi></m:msub><m:annotation encoding="math/tex">N_x</m:annotation></m:semantics></m:math>, then about <m:math><m:semantics><m:mrow><m:msub><m:mi>N</m:mi><m:mi>h</m:mi></m:msub><m:msub><m:mi>N</m:mi><m:mi>x</m:mi></m:msub></m:mrow><m:annotation encoding="math/tex">N_h N_x</m:annotation></m:semantics></m:math> operations would be required to compute this convolution. It would also be possible to compute the output through circular convolution, by zero-padding each signal to be of length <m:math><m:semantics><m:mrow><m:msub><m:mi>N</m:mi><m:mi>h</m:mi></m:msub><m:mo>+</m:mo><m:msub><m:mi>N</m:mi><m:mi>x</m:mi></m:msub><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:annotation encoding="math/tex">N_h+N_x-1</m:annotation></m:semantics></m:math>, and then circularly convolving the zero-padded signals. This would not save any computational steps, but it is a significant insight because the circular convolution could be performed by using DFTs: simply take the DFT of each zero-padded signal, multiply the two DFTs together, then take the inverse DFT of the result. Again, this does not at first seem to save any computational steps, and in fact seems to add even more, except that we have seen that the FFT is able to perform DFTs in about <m:math><m:semantics><m:mrow><m:mi>N</m:mi><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mi>N</m:mi></m:mrow><m:annotation encoding="math/tex">N\log_2 N</m:annotation></m:semantics></m:math> operations. What that means is that if we zero-pad <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math> and <m:math><m:semantics><m:mrow><m:mi>h</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">h[n]</m:annotation></m:semantics></m:math>, then take the DFT of each (using the FFT algorithm), multiply these two together, then take the inverse DFT of the result, we can find the system output in about <m:math><m:semantics><m:mrow><m:mn>2</m:mn><m:mo stretchy="false">(</m:mo><m:msub><m:mi>N</m:mi><m:mi>h</m:mi></m:msub><m:mo>+</m:mo><m:msub><m:mi>N</m:mi><m:mi>x</m:mi></m:msub><m:mo>−</m:mo><m:mn>1</m:mn><m:mo stretchy="false">)</m:mo><m:msub><m:mi>log</m:mi><m:mn>2</m:mn></m:msub><m:mo>⁡</m:mo><m:mo stretchy="false">(</m:mo><m:msub><m:mi>N</m:mi><m:mi>h</m:mi></m:msub><m:mo>+</m:mo><m:msub><m:mi>N</m:mi><m:mi>x</m:mi></m:msub><m:mo>−</m:mo><m:mn>1</m:mn><m:mo stretchy="false">)</m:mo></m:mrow><m:annotation encoding="math/tex">2(N_h+N_x-1)\log_2 (N_h+N_x-1)</m:annotation></m:semantics></m:math> operations. As signal lengths increase, this can end up being huge computational savings over the <m:math><m:semantics><m:mrow><m:msub><m:mi>N</m:mi><m:mi>h</m:mi></m:msub><m:msub><m:mi>N</m:mi><m:mi>x</m:mi></m:msub></m:mrow><m:annotation encoding="math/tex">N_h N_x</m:annotation></m:semantics></m:math> operations it would take to find the output through a convolution sum. Below is a graphical depiction of the steps to quickly find the output, with the help of the FFT:
</para><figure id="fastConvo"><media id="fastConvo-plot" alt="Image">
          <image mime-type="image/png" src="../../media/fastconv.png" width="500" print-width="500"/>
        </media>
        
      <caption>Through zero-padding and forward and inverse DFTs, using the FFT algorithm, an LTI system's output can be found efficiently.</caption></figure></section>
  </content>
</document>