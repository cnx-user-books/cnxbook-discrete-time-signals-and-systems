<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML">

<title>Signal Properties</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m57514</md:content-id>
  <md:title>Signal Properties</md:title>
  <md:abstract/>
  <md:uuid>8491d0e5-4142-43f2-890c-a8807e0f9b02</md:uuid>
</metadata>

<content>
  <para id="eip-890"><title>Signal Classification</title>Signals can be broadly classified as discrete-time or continuous-time, depending on whether the independent variable is integer-valued or real-valued.  Signals may also be either real-valued or complex-valued.  We will now consider some of the other ways we can classify signals.</para><para id="delete_me"><title>Signal Length: Finite/Infinite</title>This classification is just as it sounds. An <term>infinite-length</term> discrete-time signal takes values for all time indices: all integer values <m:math><m:mi>n</m:mi></m:math> on the number line from <m:math><m:mo>-</m:mo><m:infinity/></m:math> all the way up to <m:math><m:infinity/></m:math>.  A <term>finite-length</term> signal is defined only for a certain range of <m:math><m:mi>n</m:mi></m:math>, from some <m:math><m:msub><m:mi>N </m:mi><m:mn>1</m:mn></m:msub></m:math> to <m:math><m:msub><m:mi>N </m:mi><m:mn>2</m:mn></m:msub></m:math>.  The signal is not defined outside of that range.</para><para id="eip-993"><title>Signal Periodicity</title>As the name suggests, <term>periodic</term> signals are those that repeat themselves.  Mathematically, this means that there exists some integer value <m:math><m:mi>N</m:mi></m:math> for which <m:math><m:apply><m:eq/><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:apply><m:plus/><m:ci>n</m:ci><m:ci>N</m:ci></m:apply></m:apply><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:ci>n</m:ci></m:apply></m:apply></m:math>, for all values of <m:math><m:mi>n</m:mi></m:math>. So if we define a fundamental period of this particular signal of length, like <m:math><m:apply><m:eq/><m:mi>N</m:mi><m:mn>8</m:mn></m:apply></m:math>, then we will see the same signal values shifted by <m:math><m:mn>8</m:mn></m:math> time indices,
by <m:math><m:mn>16</m:mn></m:math>, <m:math><m:mn>-8</m:mn></m:math>, <m:math><m:mn>-16</m:mn></m:math>, etc.  Below is an example of a periodic signal:
<figure id="sigFunPer"><media id="sigFunPerplot" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunPer.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunPer.eps" for="pdf"/></media>
  <caption>A periodic discrete-time signal.  Note how it repeats every 8 time units.</caption></figure>
So periodic signals repeat, and clearly periodic signals
are going to be, therefore, infinite in length.
It's also important to remember that to be periodic in discrete-time, the period <m:math><m:mi>N</m:mi></m:math> must be an integer.  If there is no such integer-valued <m:math><m:mi>N</m:mi></m:math> for which <m:math><m:apply><m:eq/><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:apply><m:plus/><m:ci>n</m:ci><m:ci>N</m:ci></m:apply></m:apply><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:ci>n</m:ci></m:apply></m:apply></m:math> (for all values of <m:math><m:mi>n</m:mi></m:math>), then we classify the signal as being <term>aperiodic</term>.
</para><para id="eip-96"><title>Converting Between Infinite and Finite Length</title>In different applications, the need will arise to convert a signal from infinite-length to finite-length, and vice versa.  There are many ways this operation can be accomplished, but we will consider the most common.</para><para id="eip-707">The most straightforward way to create a finite-length signal from an infinite-length one is through the process of <term>windowing</term>.  A windowing operation extracts a contiguous portion of an infinite-length signal, that portion becoming the new finite-length signal.  Sometimes a window will also scale the smaller portion in a particular way.  Below is a mathematical expression of windowing (without any scaling):</para><para id="eip-799"><m:math>
<m:apply><m:eq/>
     <m:apply><m:ci type="fn" class="discrete">y</m:ci>
     <m:ci>n</m:ci></m:apply>

     <m:piecewise>
          <m:piece>
                <m:apply><m:ci type="fn" class="discrete">x</m:ci>
     <m:ci>n</m:ci></m:apply>
                <m:apply><m:leq/><m:apply><m:leq/><m:msub><m:mi>N</m:mi><m:mn>1</m:mn></m:msub><m:mi>n</m:mi>
                </m:apply><m:msub><m:mi>N</m:mi><m:mn>2</m:mn></m:msub></m:apply>
          </m:piece>
          <m:piece><m:mtext>undefined</m:mtext><m:mtext>else</m:mtext></m:piece>
     </m:piecewise>
</m:apply></m:math></para><para id="eip-828">Below is a signal <m:math><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:ci>n</m:ci></m:apply></m:math> (assume it is infinite-length, with only a part of it shown), with a portion of it extracted to create <m:math><m:apply><m:ci type="fn" class="discrete">y</m:ci><m:ci>n</m:ci></m:apply></m:math>:
<figure id="sigFunW" orient="vertical"><subfigure id="sigFunW1plot">
<media id="sigFunW1" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunW1.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunW1.eps" for="pdf"/></media><caption>Infinite-length signal (only a portion of it is shown)</caption>
</subfigure>
<subfigure id="sigFunW2">
<media id="sigFunW2plot" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunW2.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunW2.eps" for="pdf"/></media><caption>Finite-length signal</caption>
</subfigure>
<caption>(a) an infinite-length signal <m:math><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:ci>n</m:ci></m:apply></m:math> (only part of it shown) has a portion extracted via windowing to create (b) a finite-length signal <m:math><m:apply><m:ci type="fn" class="discrete">y</m:ci><m:ci>n</m:ci></m:apply></m:math>.</caption></figure></para><para id="eip-716">There are two ways a signal can be converted from a finite-length to infinite-length.  The first is referred to as <term>zero-padding</term>.  It is easy to take a finite-length signal and then make a larger finite-length signal out of it: just extend the time axis.  We have to decide what values to put in the new time locations, and simply putting <m:math><m:mn>0</m:mn></m:math> at all the new locations is a common approach. Here is how it looks, mathematically, to create a longer signal <m:math><m:apply><m:ci type="fn" class="discrete">y</m:ci><m:ci>n</m:ci></m:apply></m:math> from a shorter signal <m:math><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:ci>n</m:ci></m:apply></m:math> defined only on <m:math><m:apply><m:leq/><m:apply><m:leq/><m:msub><m:mi>N</m:mi><m:mn>1</m:mn></m:msub><m:mi>n</m:mi>
                </m:apply><m:msub><m:mi>N</m:mi><m:mn>2</m:mn></m:msub></m:apply></m:math>:</para><para id="eip-563"><m:math>
<m:apply><m:eq/>
     <m:apply><m:ci type="fn" class="discrete">y</m:ci>
     <m:ci>n</m:ci></m:apply>

     <m:piecewise>

<m:piece>
                <m:mn>0</m:mn>
                <m:apply><m:lt/><m:apply><m:leq/><m:msub><m:mi>N</m:mi><m:mn>0</m:mn></m:msub><m:mi>n</m:mi>
                </m:apply><m:msub><m:mi>N</m:mi><m:mn>1</m:mn></m:msub></m:apply>
          </m:piece>

          <m:piece>
                <m:apply><m:ci type="fn" class="discrete">x</m:ci>
     <m:ci>n</m:ci></m:apply>
                <m:apply><m:leq/><m:apply><m:leq/><m:msub><m:mi>N</m:mi><m:mn>1</m:mn></m:msub><m:mi>n</m:mi>
                </m:apply><m:msub><m:mi>N</m:mi><m:mn>2</m:mn></m:msub></m:apply>
          </m:piece>
          
<m:piece>
                <m:mn>0</m:mn>
                <m:apply><m:leq/><m:apply><m:lt/><m:msub><m:mi>N</m:mi><m:mn>2</m:mn></m:msub><m:mi>n</m:mi>
                </m:apply><m:msub><m:mi>N</m:mi><m:mn>3</m:mn></m:msub></m:apply>
          </m:piece>


     </m:piecewise>
</m:apply></m:math></para><para id="eip-935">Here, obviously <m:math><m:apply><m:lt/><m:msub><m:mi>N</m:mi><m:mn>0</m:mn></m:msub>
<m:apply><m:lt/><m:apply><m:lt/><m:msub><m:mi>N</m:mi><m:mn>1</m:mn></m:msub><m:msub><m:mi>N</m:mi><m:mn>2</m:mn></m:msub>
                </m:apply><m:msub><m:mi>N</m:mi><m:mn>3</m:mn></m:msub></m:apply></m:apply></m:math>, and if we extend <m:math><m:msub><m:ci>N</m:ci><m:mn>0</m:mn></m:msub></m:math> and <m:math><m:msub><m:mi>N</m:mi><m:mn>3</m:mn></m:msub></m:math> to negative and positive infinity, respectively, then <m:math><m:apply><m:ci type="fn" class="discrete">y</m:ci><m:ci>n</m:ci></m:apply></m:math> will end up being infinite-length.</para><para id="eip-248">The other way to make an infinite-length signal from a finite-length one is to <term>periodize</term> it, which means replicating a finite-length signal over and over to create an infinite-length periodic version.  Mathematically, that means defining the new infinite-length periodic signal like this:<code>\begin{eqnarray*}
y[n] &amp;=&amp; \sum_{m=-\infty}^{\infty} x[n-mN], \quad n\in\Integers \\
 &amp;=&amp; \cdots + x[n+2N] + x[n+N] + x[n] + x[n-N] + x[n-2N] + \cdots
\end{eqnarray*}</code></para><para id="eip-58">Graphically, we can see that this amounts to repeating the signal over and over, before and after the original portion:
<figure id="sigFunPers" orient="vertical"><subfigure id="sigFunPer1plot">
<media id="sigFunPer1" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunPer1.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunPer1.eps" for="pdf"/></media><caption>Finite-length signal</caption>
</subfigure>
<subfigure id="sigFunPer2plot">
<media id="sigFunPer2" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunPer2.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunPer2.eps" for="pdf"/></media><caption>Original signal periodized to create an infinite-length signal.</caption>
</subfigure>
<caption>(a) finite-length signal <m:math><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:ci>n</m:ci></m:apply></m:math> is periodized to create (b) an infinite-length signal <m:math><m:apply><m:ci type="fn" class="discrete">y</m:ci><m:ci>n</m:ci></m:apply></m:math> (only a portion of it is shown).</caption></figure></para><para id="eip-711"><title>Periodization and Modular Arithmetic</title>It turns out that, as we consider periodization and periodic signals, the notion of modular arithmetic will be helpful.  In modular arithetic, integers do not lie on a line stretching from negative infinity to infinity, but rather on a circle of a defined size $N$. In modulo-8, for example, the numbers are 8 "hours" on a "clock."  Our convention will be for the numbers to traverse from 0 to $N-1$, counterclockwise:
<figure id="clock1"><media id="clock1plot" alt="Image">
<image mime-type="image/png" src="../../media/clock1.png" width="150"/>
</media>
  <caption>CAPTION.</caption></figure></para><para id="eip-29">Consider a finite-length signal of size $N$. We can align the time-dependent values of the signal on the modulo circle:
<figure id="clockSig1"><media id="clockSig1plot" alt="Image">
<image mime-type="image/png" src="../../media/clockSig1.png" width="200"/>
</media><caption>CAPTION.</caption></figure>
When we travel around the clock once, from time index 0 to 7, we express the finite-length signal.  But if we keep traveling, in one direction or the other, then that amounts to periodizing the signal.  Using our modulo notation, we can periodize a finite-length signal <m:math><m:apply><m:ci type="fn" class="discrete">x</m:ci><m:ci>n</m:ci></m:apply></m:math> to be an infinite-length periodic signal <m:math><m:apply><m:ci type="fn" class="discrete">y</m:ci><m:ci>n</m:ci></m:apply></m:math> like this: $y[n]=x[(n)_N]$.</para><para id="eip-783"><title>Finite/Periodic Signals Relationship</title>We have seen that we can take an $N$-length finite-length signal and periodize it to make an infinite-length periodic signal with a period of $N$.  By the same token, we can also work in reverse and extract one period worth of signal from any periodic signal to create a finite-length signal. <emphasis>What this means is we can consider periodic signals and finite-length signals to be essentially equivalent</emphasis>: we can consider just one period of a periodic signal (the rest of the signal is redundant, by definition), or periodize a finite-length signal.  They are two ways of looking at the same thing, a phenomenon we will often see in our study of signals and systems, and we will choose the perspective that best suits our needs for particular applications.</para><para id="eip-677"><title>Shifting Infinite-length Signals</title>Given some signal $x[n]$, it will often be necessary for us to consider that signal shifted in time.  We denote such a shift mathematically with an expression like $x[n-m]$, where $m$ is some integer.  If $m$ is greater than zero, then $x[n-m]$ will be just like $x[n]$, except it will be shifted to the right by $m$ time units.  If $m$ is less than zero, it will be shifted to the left.  Here is who that might look for a couple values of $m$:
<figure id="sigfunshifts" orient="vertical"><subfigure id="sfs1">
<media id="sfs1p" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunS1.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunS1.eps" for="pdf"/></media><caption>Original signal $x[n]$.</caption>
</subfigure>
<subfigure id="sfs2">
<media id="sfs2p" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunS2.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunS2.eps" for="pdf"/></media><caption>$x[n]$ shifted to the right.</caption>
</subfigure>
<subfigure id="sfs3">
<media id="sfs3p" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunS3.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunS3.eps" for="pdf"/></media><caption>$x[n]$ shifted to the left.</caption>
</subfigure>
<caption>A (a) signal $x[n]$ shifted according to the expression $x[n-m]$ where $m$ is (b) positive, and (c) negative.</caption></figure>
This type of shifting works the same with periodic signals:
<figure id="perfunshifts" orient="vertical"><subfigure id="sfps0">
<media id="sfps0p" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunPerS0.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunPerS0.eps" for="pdf"/></media><caption>Original periodic signal $y[n]$.</caption></subfigure>
<subfigure id="sfps1"><media id="sfps1p" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunPerS1.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunPerS1.eps" for="pdf"/></media><caption>$y[n]$ shifted to the right.</caption>
</subfigure>
<caption>A periodic signal shifted one value in time.</caption></figure>
Of course, for periodic signals, certain shifts actually do not have any effect on them.  If a signal repeats with a period of $N$, then shifting that signal by any integer multiple of $N$ will yield the original signal.  Take a look at the signal above, which was shifted to the right by a time unit of 1.  If we keep on shifting it until it is shifted 8 time units the result will be identical to the original signal.</para><para id="eip-192"><title>Shifting Finite-Length Signals</title>Can finite-length signals be shifted, as well?  There does not seem to be any reason why not.  Suppose we have some finite-length signal $x[n]$ (of length $N$) and we define another finite-length signal $v[n]$ to be $v[n]=x[n-1]$. So we have $v[1]=x[0]$ and $v[2]=x[1]$ and so on until $v[N-1]=x[N-2]$. But what about $v[0]$, what do we put there?  And how about $x[N-1]$, where is that supposed to go?  We do not want to invent information to put in $v[0]$, nor lose the information of $x[N-1]$. An elegant solution is to periodize $x[n]$, and then consider the relation $v[n]=x[n-1]$.  In this case, we now have a value for $v[0]$: $v[0]=x[-1]$.  Since $x[n]$ is periodic with period $N$, it also happens that $x[-1]=x[N-1]$, so we do not lose that information.</para><para id="eip-545">This kind of operation, for finite-length signals, is called a <term>circular shift</term>, and we can express it mathematically with the help of our modular arithmetic operator. Circularly shifting a finite-length signal $x[n]$ by $m$ time units is expressed as $x[(n-m)_N]$. It can also be visualized by turning $x[n]$ about the circle on which it resides:
<figure id="clockshifts" orient="horizontal"><subfigure id="cs1">
<media id="cs1p" alt="Image">
<image mime-type="image/png" src="../../media/clockSig1.png" width="150"/>
</media><caption>Original finite-length signal $x[n]$.</caption></subfigure>
<subfigure id="cs2"><media id="cs2p" alt="Image">
<image mime-type="image/png" src="../../media/clockSig2.png" width="150"/>
</media><caption>$x[(n-3)_8]$</caption>
</subfigure>
<caption>Circularly shifting a signal by $m$ amounts to turning it counter-clockwise $m$ steps.</caption></figure></para><para id="eip-753"><title>Time Reversing Finite-Length Signals</title>For infinite length signals, the transformation of reversing the time axis $x[−n]$ is obvious: just flip the signal about $n=0$. But things are not quite so obvious for finite-length signals; if a signal is defined for, say, $n$ between 0 and N, then what gets flipped across the $n=0$ from the negative side? Once again, it turns out the modular arithmetic opererator can be called in for help. We reverse the time axis, modulo N: $x[(-n)_N]$. Below is an image of a finite-length ($N=8$) signal, time-reversed:
<figure id="clock4"><media id="clock4plot" alt="Image">
<image mime-type="image/png" src="../../media/clockSig4.png" width="150"/>
</media>
  <caption>We can time reverse a finite-length signal $x[n]$ with the mathematical expression $x[(-n)]_8$.</caption></figure></para><para id="eip-641"><title>Signal Causality</title>A signal $x[n]$ is <term>causal</term> if $x[n]=0$ for all $n \lt 0$, it is <term>anti-causal</term> if $x[n]=0$ for all $n \geq 0$, and it is <term>acausal</term> if is neither causal nor anti-causal.

<figure id="sigFunCausal" orient="vertical"><subfigure id="sigFunCausplot">
<media id="sigFunCaus" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunCaus.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunCaus.eps" for="pdf"/></media><caption>A causal signal.</caption>
</subfigure>
<subfigure id="sigFunACausplot">
<media id="sigFunACaus" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunACaus.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunACaus.eps" for="pdf"/></media><caption>An anti-causal signal.</caption>
</subfigure>
</figure></para><para id="eip-560"><title>Even and Odd Signals</title>A signal $x[n]$is defined as <term>even</term> if $x[-n]=x[n]$, and <term>odd</term> if $x[-n]=-x[n]$.
<figure id="sigevod" orient="vertical"><subfigure id="sigFunE1plot">
<media id="sigFunE1" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunE1.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunE1.eps" for="pdf"/></media><caption>An even signal.</caption>
</subfigure>
<subfigure id="sigFunO1plot">
<media id="sigFunO1" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunO1.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunO1.eps" for="pdf"/></media><caption>An odd signal.</caption>
</subfigure>
</figure></para><para id="eip-215"><title>Even/Odd Signal Decomposition</title>MM: Is it really necessary to include this? Usage of the concept (wavelets?) is outside the scope of the class.</para><para id="eip-988"><title>Digital Signals</title><term>Digital</term> signals are a special sub-class of discrete-time signals.  While the independent time variable for discrete-time signals is integer-valued, the dependent variable (i.e., the value the signal takes at any given time) can take on any value. However, for digital signals, both of these variables are discrete-valued.  Rather than take any value on a continuum, discrete signals take only a limited number of values, or <term>levels</term>. Typically, the number of levels is expressed as $D = 2^q$, and each possible value of $x[n]$ is represented as a digital code with $q$ bits.
<figure id="sigFunQ"><media id="sigFunQplot" alt="Image">
<image mime-type="image/svg+xml" src="../../media/sigFunQ.svg"/>
<image mime-type="application/postscript" src="../../media/sigFunQ.eps" for="pdf"/></media>
  <caption>A digital signal with $q = 2$ bits, so $D = 2^2= 4$ levels.</caption></figure></para></content>

</document>