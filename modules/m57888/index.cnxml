<document xmlns="http://cnx.rice.edu/cnxml">
  <title>Matched Filters</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m57888</md:content-id>
  <md:title>Matched Filters</md:title>
  <md:abstract/>
  <md:uuid>3177f913-457f-4e88-9e72-4709c2379d0e</md:uuid>
</metadata>

<content>
    <para id="delete_me">Most discrete-time filters aim to modify an input signal according to desired performance in the frequency domain; for example, a low-pass filter attenuates the high frequency components of an input signal. However, there may be instances in which the goals of the filter are best understood in the time domain. One example of such a filter is the <term>matched filter</term>.</para>
    <para id="eip-818">The objective of a matched filter is very straightforward: find the location where a particular signal occurs within another (larger) signal. While this is a task often employed in children's games (I Spy) or puzzles (Where's Waldo), it of course has more "grown up" uses, as well: for example, sonar and radar work by transmitting a signal and then listening (searching) for an echoed version of it.</para><para xmlns:m="http://www.w3.org/1998/Math/MathML" id="idm182287799408">We have already considered a signal processing technique that works very well at finding one signal in another. Recall what the inner product operation does. The inner product of two signals <m:math><m:semantics><m:mrow><m:mi>x</m:mi></m:mrow><m:annotation encoding="math/tex">x</m:annotation></m:semantics></m:math> and <m:math><m:semantics><m:mrow><m:mi>y</m:mi></m:mrow><m:annotation encoding="math/tex">y</m:annotation></m:semantics></m:math>, <m:math><m:semantics><m:mrow><m:mo fence="false" stretchy="false">⟨</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo fence="false" stretchy="false">⟩</m:mo><m:mo>=</m:mo><m:munder><m:mo>∑</m:mo><m:mi>n</m:mi></m:munder><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:msup><m:mi>y</m:mi><m:mo>∗</m:mo></m:msup><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">\langle x,y\rangle=\sum_n x[n]y^*[n]</m:annotation></m:semantics></m:math>, measures the their correspondence: the more alike the two signals are, the greater the inner product will be. The more unlike they are, the smaller it will be, with a minimum absolute value of zero (which means the signals are orthogonal).</para><para id="eip-28">So it makes sense, then, that the process of matched filtering will use inner products. But it will take more than a single inner product, for we are looking for <emphasis effect="italics">where </emphasis>a small signal occurs in a larger one. What we would like to do is perform an inner product between the small signal at every possible time location in the larger signal, and then examine where in the large signal this inner product is at its greatest. If we would like to find where the signal <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math> occurs in signal <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math>, then we would simply calculate <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mo fence="false" stretchy="false">⟨</m:mo><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mo>,</m:mo><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo>−</m:mo><m:mi>m</m:mi><m:mo stretchy="false">]</m:mo><m:mo fence="false" stretchy="false">⟩</m:mo></m:mrow><m:annotation encoding="math/tex">\langle y[n],x[n-m]\rangle</m:annotation></m:semantics></m:math> at every time instance <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>m</m:mi></m:mrow><m:annotation encoding="math/tex">m</m:annotation></m:semantics></m:math> and note where the maximum value occurs. </para>
    <figure xmlns:m="http://www.w3.org/1998/Math/MathML" id="idm182287767872" orient="vertical"><subfigure id="idm182287767152">
        <media id="idm182287766992" alt="">
          <image mime-type="" src="../../media/xsignal.png"/>
<image mime-type="application/postscript" src="../../media/xsignal.eps" for="pdf"/>
        </media>
      </subfigure>
      <subfigure id="idm182287765776">
        <media id="idm182287765648" alt="">
          <image mime-type="" src="../../media/ysignalScnx.png"/>
<image mime-type="application/postscript" src="../../media/ysignalScnx.eps" for="pdf"/>
        </media>
      </subfigure>
      <subfigure id="idm182287764432">
        <media id="idm182287764304" alt="">
          <image mime-type="" src="../../media/xysignalScnx.png"/>
<image mime-type="application/postscript" src="../../media/xysignalScnx.eps" for="pdf"/>
        </media>
      </subfigure>
      
    <caption>Suppose we would like to know where the signal <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math> occurs within <m:math><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math>. Visually, we can see the location is <m:math><m:semantics><m:mrow><m:mi>n</m:mi><m:mo>=</m:mo><m:mn>15</m:mn></m:mrow><m:annotation encoding="math/tex">n=15</m:annotation></m:semantics></m:math>, but to solve the problem algorithmically, we would want to take the inner product of the small signal against <m:math><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math> at every time point.</caption></figure><para id="eip-776">If the process of taking an inner product at every time location in a signal sounds familiar, it is because that is essentially what discrete-time convolution is! Noting that the usual definition switches the <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>m</m:mi></m:mrow><m:annotation encoding="math/tex">m</m:annotation></m:semantics></m:math> and <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>n</m:mi></m:mrow><m:annotation encoding="math/tex">n</m:annotation></m:semantics></m:math> variables, recall the convolution sum:</para>
    <para id="idm182287758352"><m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>y</m:mi><m:mo>∗</m:mo><m:mi>x</m:mi><m:mo>=</m:mo><m:munder><m:mo>∑</m:mo><m:mi>n</m:mi></m:munder><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>m</m:mi><m:mo>−</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y\ast x=\sum_n y[n]x[m-n]</m:annotation></m:semantics></m:math>.</para>
    <para id="idm182287749520">At every time location in the signal, the convolution sum is performing an inner-product like operation between <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math> and <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mo>−</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[-n]</m:annotation></m:semantics></m:math>. The only thing that is missing for it to be an inner product is complex conjugation, so technically the convolution sum is performing an inner product between <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math> and <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:msup><m:mi>x</m:mi><m:mo>∗</m:mo></m:msup><m:mo stretchy="false">[</m:mo><m:mi>m</m:mi><m:mo>−</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x^*[m-n]</m:annotation></m:semantics></m:math>; it is determining how similar <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math> and <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:msup><m:mi>x</m:mi><m:mo>∗</m:mo></m:msup><m:mo stretchy="false">[</m:mo><m:mo>−</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x^*[-n]</m:annotation></m:semantics></m:math> are at time <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>m</m:mi></m:mrow><m:annotation encoding="math/tex">m</m:annotation></m:semantics></m:math>. So if we would like to find where <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math> occurs in <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math>, then we would simply need to carry out the convolution <m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mo>∗</m:mo><m:msup><m:mi>x</m:mi><m:mo>∗</m:mo></m:msup><m:mo stretchy="false">[</m:mo><m:mo>−</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]\ast x^*[-n]</m:annotation></m:semantics></m:math> and find its maximum value.</para>
    <figure xmlns:m="http://www.w3.org/1998/Math/MathML" id="idm182287711760" orient="vertical"><subfigure id="idm182287710992">
        <media id="idm182287710864" alt="">
          <image mime-type="" src="../../media/xsignal.png"/>
<image mime-type="application/postscript" src="../../media/xsignal.eps" for="pdf"/>
        </media>
      </subfigure>
      <subfigure id="idm182287709648">
        <media id="idm182287709520" alt="">
          <image mime-type="" src="../../media/ysignalScnx.png"/>
<image mime-type="application/postscript" src="../../media/ysignalScnx.eps" for="pdf"/>
        </media>
      </subfigure>
      <subfigure id="idm182287708304">
        <media id="idm182287708176" alt="">
          <image mime-type="" src="../../media/dsignal.png"/>
<image mime-type="application/postscript" src="../../media/dsignal.eps" for="pdf"/>
        </media>
      </subfigure>
      <caption>The peak value of <m:math><m:semantics><m:mrow><m:mi>d</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mo>=</m:mo><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo><m:mo>∗</m:mo><m:msup><m:mi>x</m:mi><m:mo>∗</m:mo></m:msup><m:mo stretchy="false">[</m:mo><m:mo>−</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">d[n]=y[n]\ast x^*[-n]</m:annotation></m:semantics></m:math> indicates where the signal <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math> occurs within <m:math><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math>.</caption>
    </figure><para xmlns:m="http://www.w3.org/1998/Math/MathML" id="idm182287690368">Since we are looking for the maximum value, or (if we believe the signal may occur more than once in the larger signal) for some threshold to be met, matched filtering can be used in the presence of noise. In the example above, <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math> appears in a noisy signal <m:math><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math>, but the convolution sum does not mind--it simply finds for us the location in <m:math><m:semantics><m:mrow><m:mi>y</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">y[n]</m:annotation></m:semantics></m:math> with the strongest correlation to <m:math><m:semantics><m:mrow><m:mi>x</m:mi><m:mo stretchy="false">[</m:mo><m:mi>n</m:mi><m:mo stretchy="false">]</m:mo></m:mrow><m:annotation encoding="math/tex">x[n]</m:annotation></m:semantics></m:math>. Because matched filtering works in this way, it is also sometimes referred to as cross correlation (especially in statistical contexts).</para></content>
</document>